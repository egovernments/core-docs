# Microservices and Low Code No Code

Microservices and Low Code No Code architectures have evolved to address very different sets of software engineering challenges. With the advent of information technology and especially after its explosion in the post internet era, two major problems emerged.&#x20;

1\. Scale Problem - How to design cost effective, evolvable and reliable systems that can be scalable to meet requirements of millions of users.&#x20;

2\. Speed Problem - How to accelerate the development of software?

To address the scaling problem, technology companies and systems designers created design concepts and technologies like hardware virtualization (cloud), containers (e.g. Docker), Service Orientation (e.g. API First approach), Asynchronous Processing (e.g. Queues) etc. These technologies and design concepts eventually were put together into microservices based architecture and are now used to develop large scalable systems.&#x20;

To address the speed problem of software development, early engineers focused on automatic code generation using CASE Tools. CASE Tools aimed to generate “high quality, defect free, maintainable software”. Key idea was to use software design models like ER Diagrams, Data Flow Diagrams as input and then generate code from these diagrams. Several of these tools became popular in the 90’s. The main problem with these tools was that when the programmers made changes to the generated code the source model would go out of sync and would become unusable. This limited the adoption of CASE tools to the initial phases of the projects. Similar concepts are used even today by many developers to generate the boilerplate code instead of coding everything from scratch.

In parallel to CASE tools, 4GL (Fourth Generation Languages) and RAD (Rapid Application Development) also began trending. 4GL was first introduced by James Martin in 1981 in his book “Application Development without Programmers”. 4GL languages focused on higher level constructs like information rather than bits and bytes. They focused on databases, reports, workflows, GUI (Graphical user interface) etc. 4GL languages accompanied with Drag and Drop for form designers. Soon, people realized that programming done in higher language constructs has limited applicability (due to lower expressivity). They are harder to refactor. Most of the 4GL were focused on traditional Windows based applications. The internet moved user interfaces to HTML and this made 4GL languages less relevant. Most companies who bet on 4GL rebranded themselves to Business Process Management (BPM) or Rules Engines. The 4GL trend faded away.

The other trend was Rapid Application Development (RAD). Early software development process was adopted from civil engineering which was an extremely rigid waterfall process i.e. after requirements, then design then build and then deployment. No back and forth was accepted. RAD changed that by allowing feedback loops between various stages of development. This allowed developers to incorporate learning during one phase into the previous phase. So basically, some back and forth was allowed. Using CASE tools for design and generating working models were quite suited with this approach.

Low Code No Code environments trace their roots to CASE, 4GL and RAD. The principles are the same - model-driven design, automatic code generation, and visual programming. Their benefits and limitations are also the same. They can generate simple applications quite fast. However these applications will inherently suffer from low expressivity, extensibility, evolvability and scalability. The platform providers hide behind “Low Code” by providing the ability to write code within the designer. As complexity of applications increases, developers end up writing more and more code to incorporate these functionalities. Given there are no standards existing for LCNC platforms today, the underlying models and pieces of code are all stored in proprietary formats. This creates significant vendor lock-in.

Given the need to generate large number of simple applications and shortage of software engineering talent, a combination of backend microservices with a low code no code front end may be the way to move forward. This would enable both scalable systems can be delivered at speed. However, with increasing diversity of channels - web, mobile, chat, voice, kiosks, social media etc. the challenge for low code no code platforms has significantly been raised. A low code no code platform that can integrate/orchestrate backend microservices and enable digital service delivery through a wide number of channels is the need of the hour.&#x20;

At the same time, while microservices based architectures has been really successful in addressing the issues around scale and maintainability, it has led to increasing complexity of deployment and operations. A plethora of tools are emerging to address these issues. A DevOps engineer needs to be aware of these tools to be able deploy and manage microservices.&#x20;



[![Creative Commons License](https://i.creativecommons.org/l/by/4.0/80x15.png)\_\_](http://creativecommons.org/licenses/by/4.0/)_All content on this website by_ [_eGov Foundation_ ](https://egov.org.in/)_is licensed under a_ [_Creative Commons Attribution 4.0 International License_](http://creativecommons.org/licenses/by/4.0/)_._
